# ---------------------------
# app/qif_indexer.py
# ---------------------------
import os
import pandas as pd
import logging
from sqlalchemy import create_engine, Column, Float, String, Date, MetaData, Table
from datetime import date
from qifparse.parser import QifParser

class QIFIndexer:
    def __init__(self, qif_dir: str, db_path: str):
        self.qif_dir = qif_dir
        self.db_path = db_path
        self.logger = logging.getLogger('qif_indexer')
        self.logger.setLevel(logging.INFO)
        # Enable SQL echo for debugging
        self.engine = create_engine(
            f"sqlite:///{db_path}",
            connect_args={"check_same_thread": False},
            echo=True
        )
        self.metadata = MetaData()
        # Define transactions table schema
        self.transactions = Table(
            'transactions', self.metadata,
            Column('date', Date),
            Column('payee', String),
            Column('category', String),
            Column('memo', String),
            Column('amount', Float),
        )

    # def parse_qif(self) -> pd.DataFrame:
    #     self.logger.info(f"Parsing QIF files in directory: {self.qif_dir}")
    #     records = []
    #     files = [f for f in os.listdir(self.qif_dir) if f.lower().endswith('.qif')]
    #     self.logger.info(f"Found {len(files)} QIF files")
    #     for fname in files:
    #         path = os.path.join(self.qif_dir, fname)
    #         self.logger.info(f"Parsing file: {path}")
    #         with open(path, 'r', encoding='utf-8', errors='ignore') as f:
    #             lines = [l.strip() for l in f if l.strip()]
    #         current = {}
    #         for line in lines:
    #             if line == '^':
    #                 try:
    #                     date = datetime.strptime(current.get('date', ''), '%Y-%m-%d').date()
    #                 except Exception:
    #                     date = None
    #                 amount = float(current.get('amount', '0').replace(',', ''))
    #                 records.append({
    #                     'date': date,
    #                     'payee': current.get('payee', ''),
    #                     'category': current.get('category', ''),
    #                     'memo': current.get('memo', ''),
    #                     'amount': amount,
    #                 })
    #                 current = {}
    #             else:
    #                 key, val = line[0], line[1:]
    #                 if key == 'D': current['date'] = val
    #                 elif key == 'P': current['payee'] = val
    #                 elif key == 'L': current['category'] = val
    #                 elif key == 'M': current['memo'] = val
    #                 elif key == 'T': current['amount'] = val
    #         # Catch last transaction if no trailing ^
    #         if current:
    #             try:
    #                 date = datetime.strptime(current.get('date', ''), '%Y-%m-%d').date()
    #             except Exception:
    #                 date = None
    #             amount = float(current.get('amount', '0').replace(',', ''))
    #             records.append({
    #                 'date': date,
    #                 'payee': current.get('payee', ''),
    #                 'category': current.get('category', ''),
    #                 'memo': current.get('memo', ''),
    #                 'amount': amount,
    #             })
    #     self.logger.info(f"Parsed total {len(records)} transactions")
    #     df = pd.DataFrame(records)
    #     # Returning parsed DataFrame (verification step removed)
    #     return df

    ############## New QIF Parser Class ##############
    def parse_qif(self) -> pd.DataFrame:
        self.logger.info(f"Parsing QIF files in directory: {self.qif_dir}")
        records = []
        files = [f for f in os.listdir(self.qif_dir) if f.lower().endswith('.qif')]
        self.logger.info(f"Found {len(files)} QIF files")
        for fname in files:
            path = os.path.join(self.qif_dir, fname)
            self.logger.info(f"Parsing file: {path}")
            with open(path, 'r', encoding='utf-8', errors='ignore') as f:
                qif = QifParser.parse(f)
                for txn in qif.get_transactions():
                    rec = {
                        'date': txn.date if isinstance(txn.date, date) else None,
                        'payee': txn.payee or "",
                        'category': txn.category or "",
                        'memo': txn.memo or "",
                        'amount': float(txn.amount) if txn.amount is not None else 0.0,
                }
                records.append(rec)
        self.logger.info(f"Parsed total {len(records)} transactions")
        return pd.DataFrame(records)


    ###################################################

    def build_database(self):
        self.logger.info("Building SQLite database from parsed transactions")
        df = self.parse_qif()
        self.logger.info(f"DataFrame shape: {df.shape}")
        # Drop and recreate table
        self.metadata.drop_all(self.engine, checkfirst=True)
        self.metadata.create_all(self.engine)
        # Populate
        df.to_sql('transactions', self.engine, if_exists='append', index=False)
        self.logger.info("Database build complete")

    def ensure_database(self):
        """Ensure the database file exists and is populated."""
        if not os.path.exists(self.db_path) or os.path.getsize(self.db_path) == 0:
            self.logger.info(f"Database file {self.db_path} missing or empty; creating.")
            os.makedirs(os.path.dirname(self.db_path), exist_ok=True)
            self.build_database()
        else:
            self.logger.info(f"Database file {self.db_path} already exists and is populated.")
